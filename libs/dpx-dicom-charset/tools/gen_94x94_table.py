# Copyright, 2023 Devyatnikov Alexei <oss@stingx.ru>
#
# ## License:
# MIT OR Apache-2.0 License
#
# ## Purpose:
# Generates ISO-2022 94x94 tables from unicode.org compatible TXT descriptions
# for `dpx-dicom-charset` rust crate.
#
# ## Running:
#
# python3 gen_94x94_table.py
#
# See on-screen information on output files location.
#
# ## Description:
# Script generates 3 tables for "JIS X 0208", "JIS X 0212" and "KS X 1001"
# sourcing files from https://unicode.org public archive. The output files as
# well, as the cached downloads are placed in "<root>/target/94x94_table_temp".
#
# In case of internet archive is unavailable for some reason, you can can
# manually put files with names "JIS0208.TXT", "JIS0212.TXT" and "KSX1001.TXT"
# to a cached downloads folder "<root>/target/94x94_table_temp".
#
# Output files are supposed to be manually copied to
# "<root>/libs/dpx-dicom-charset/src/tables/multi_byte/web" folder. Test files
# are placed in "test_files" subfolder.
#
# ## Short introduction to the 94x94 tables:
# Encoded text describes element in this table using 2 characters. When the
# table in G0 region, these characters are 0x21..=0x7E. When in G1 region the
# characters are 0xA1..=0xFE. In G0 region, all the characters 0x00..0x20 and
# 0x7F are emitted as-is. Tables generated by this script assumes, that
# "initial" index corresponds to row/column 0x21,0x21 or 0xA1,0xA1.
#
# The table is organized as a big blob of rows. Each row has 94 `u16` code
# points. Invalid(unassigned) code points are 0xFFFD. Also, there is helper
# table containing row-number for each of the rows in main table. This means,
# that some rows may be skipped if all the entries are unassigned in them.

from datetime import date
from pathlib import Path
from urllib.request import urlretrieve
import os
import platform
import sys

TAB = "    "
# cSpell:ignore getlogin


class Enc:
    def __init__(self, url, file_name, pointer_column, code_column, txt_elements_separator, term, g0, prefix, description):
        self.url = url
        self.file_name = file_name
        self.pointer_column = pointer_column
        self.code_column = code_column
        self.txt_elements_separator = txt_elements_separator
        self.term = term
        self.g0 = g0
        self.prefix = prefix
        self.description = description


ENCODINGS = [
    Enc('https://unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/JIS0208.TXT', 'JIS0208.TXT',
        1, 2, b'\t',
        'ISO 2022 IR 87', True,
        'JISX0208', 'Japanese JIS X 0208: Kanji'),
    Enc('https://unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/JIS0212.TXT', 'JIS0212.TXT',
        0, 1, b'\t',
        'ISO 2022 IR 159', True,
        'JISX0212', 'Japanese JIS X 0212: Supplementary Kanji set'),
    Enc('https://unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/KSC/KSX1001.TXT', 'KSX1001.TXT',
        0, 1, b'  ',
        'ISO 2022 IR 149', False,
        'KSX1001', 'Korean KS X 1001: Hangul and Hanja'),
]


def write_static_list(f, vis, name, element_type, element_list, max_elements_on_line=8):
    line_list = []
    elements_on_line = []
    elements_count = 0
    for element in element_list:
        elements_on_line.append(element)
        elements_count += 1
        if len(elements_on_line) == max_elements_on_line:
            line_string = TAB + ', '.join(elements_on_line) + ','
            elements_on_line.clear()
            line_list.append(line_string)
    if len(elements_on_line) > 0:
        line_string = TAB + ', '.join(elements_on_line) + ','
        line_list.append(line_string)

    f.write("{}static {}: [{}; {}] = [\n{}\n];\n".format(
        vis, name, element_type, elements_count, '\n'.join(line_list)))


def parse_file(f, enc):
    # Build full non-optimized table
    full_table = [0xFFFD] * (94 * 94)
    for line in f:
        line = line.strip()
        if line.startswith(b'#') or len(line) == 0:
            continue
        line = line.split(enc.txt_elements_separator)
        pointer = int(line[enc.pointer_column], 16)
        code = int(line[enc.code_column], 16)

        row = (pointer >> 8) - 0x21
        column = (pointer & 0xFF) - 0x21
        full_table[row * 94 + column] = code

    # Eliminate empty rows and fill in final non-empty rows and it's indices
    indices = []
    table = []
    for row_index in range(0, 94):
        row = full_table[row_index * 94: (row_index + 1) * 94]
        if any(code != 0xFFFD for code in row):
            indices.append(row_index)
            table.extend(row)
    return table, indices, full_table


def write_table(f, enc, table, indices):
    def gen_text_u16(index):
        for i in index:
            yield '0x{:>04X}'.format(i)

    def gen_text_u8(index):
        for i in index:
            yield '0x{:>02X}'.format(i)

    f.write("""\
//! {description} table and forward/backward functions used
//! in ISO-2022 multi-byte codec for `{term}`

#![cfg_attr(rustfmt, rustfmt_skip)]
use crate::tables::{{ BackwardResult, ForwardResult, constants::* }};

// cSpell:{cspell}

// Do not edit! This file was autogenerated with `gen_94x94_table.py`
// utility on {date} by "{user}" on "{host}".
// Source URL: {url}

/// Unicode code points for {term}
///
/// This table contains a bunch of 94-elements rows. Exact
/// row number could be extracted from [`{prefix}_INDICES`](Self::{prefix}_INDICES)
///
/// Note: Invalid symbols are marked with `0xfffd`
""".format(
        description=enc.description, term=enc.term, cspell="disable",
        date=date.today(), user=os.getlogin(), host=platform.node(),
        url=enc.url, prefix=enc.prefix))
    write_static_list(f, '', '{}_CODES'.format(
        enc.prefix), 'u16', gen_text_u16(table), 12)

    f.write("""
/// Row indices for [`{prefix}_CODES`](Self::{prefix}_CODES)
///
/// The length of this table is exactly `{prefix}_CODES / 94`.
/// Each entry contains the original "row" index of the row
/// in {prefix}_CODES.
""".format(prefix=enc.prefix))
    write_static_list(f, '', '{}_INDICES'.format(
        enc.prefix), 'u8', gen_text_u8(indices), 16)

    if enc.g0:
        offset = 0x21
        g = "G0"
        f.write("""
/// First valid value of first and second bytes for 94x94 set addressing in G0
const FIRST_VALID_BYTE: u8 = GL_MIN + 1;
/// Last valid value of first and second bytes for 94x94 set addressing in G0
const LAST_VALID_BYTE: u8 = GL_MAX - 1;""")
    else:
        offset = 0xA1
        g = "G1"
        f.write("""
/// First valid value of first and second bytes for 94x94 set addressing in G1
const FIRST_VALID_BYTE: u8 = GR_MIN + 1;
/// Last valid value of first and second bytes for 94x94 set addressing in G1
const LAST_VALID_BYTE: u8 = GR_MAX - 1;""")

    f.write("""
/// The length of a single row in a 94x94 table
const ROW_LENGTH : usize = 94;

/// 94x94 table in `{gu}` `{term}` decoder
pub fn forward_{gl}_{prefix_l}(input: &[u8]) -> ForwardResult {{
    let c1 = input[0];
    if !matches!(c1, FIRST_VALID_BYTE..=LAST_VALID_BYTE) {{
        return (1, None);
    }}
    let Some(&c2) = input.get(1) // this handles possible end of input
        .filter(|&&c2| matches!(c2, FIRST_VALID_BYTE..=LAST_VALID_BYTE))
        else {{
            return (1, None);
        }};
    let row = c1 - FIRST_VALID_BYTE;
    let col = c2 - FIRST_VALID_BYTE;
    let decoded = {prefix}_INDICES
        .binary_search(&row).ok()
        .and_then(|index| {{
            let code = {prefix}_CODES[index * ROW_LENGTH + col as usize];
            if code != CODE_INVALID {{
                Some(code as u32)
            }} else {{
                None
            }}
        }});
    (2, decoded)
}}

/// 94x94 table in `{gu}` `{term}` decoder
pub fn backward_{gl}_{prefix_l}(output: &mut [u8], code: u32) -> BackwardResult {{
    let code = code as u16;
    {prefix}_CODES
        .iter()
        .position(|&c| c == code)
        .map(|index| {{
            let row = {prefix}_INDICES[index / ROW_LENGTH];
            let col = (index % ROW_LENGTH) as u8;
            output[0] = row + FIRST_VALID_BYTE;
            output[1] = col + FIRST_VALID_BYTE;
            2
        }})
}}
""".format(gu=g, term=enc.term, gl=g.lower(),
            prefix_l=enc.prefix.lower(), prefix=enc.prefix))


def write_test_g0(f, e, full_table):
    f.write("# CL, GL (outside 94x94), CR, GR = invalid\n")
    for c in [0x00, 0x01, 0x1F, 0x20, 0x7F, 0x80, 0x9F, 0xA0, 0xA1, 0xFE, 0xFF]:
        f.write("0x{:>02X}\t0x{:>04X}\n".format(c, 0xFFFD))
    f.write("# GL (94x94) = {}\n".format(e.prefix))
    for c in range(0, 94 * 94, 53):
        f.write("0x{:>02X}{:>02X}\t0x{:>04X}\n".format(
            c // 94 + 0x21, c % 94 + 0x21, full_table[c]))


def write_test_g1(f, e, full_table):
    f.write("# CL, GL, CR, GR(outside 94x94) = invalid\n")
    for c in [0x00, 0x01, 0x1F, 0x20, 0x21, 0x7E, 0x7F, 0x80, 0x9F, 0xA0, 0xFF]:
        f.write("0x{:>02X}\t0x{:>04X}\n".format(c, 0xFFFD))
    f.write("# GR (94x94) = {}\n".format(e.prefix))
    for c in range(0, 94 * 94, 53):
        f.write("0x{:>02X}{:>02X}\t0x{:>04X}\n".format(
            c // 94 + 0xA1, c % 94 + 0xA1, full_table[c]))


if __name__ == "__main__":
    temp_dir = os.path.join(
        Path(__file__).parents[3], "target", "gen_94x94_table")
    web_dir = os.path.join(temp_dir, "web")
    if not os.path.exists(web_dir):
        os.makedirs(web_dir)
    test_dir = os.path.join(temp_dir, 'test_files')
    if not os.path.exists(test_dir):
        os.mkdir(test_dir)

    for e in ENCODINGS:
        file_name = os.path.join(web_dir, e.file_name)
        if not os.path.exists(file_name):
            print("Downloading {} ...".format(e.file_name), file=sys.stderr)
            urlretrieve(e.url, file_name)

        print("Parsing {} ...".format(e.file_name), file=sys.stderr)
        f_source = open(file_name, 'rb')
        table, indices, full_table = parse_file(f_source, e)

        target_file_name = os.path.join(
            temp_dir, "{}.rs".format(e.prefix.lower()))
        print("Writing {} ...".format(target_file_name), file=sys.stderr)
        f_target = open(target_file_name, 'w')
        write_table(f_target, e, table, indices)

        test_file_name = os.path.join(
            test_dir, "{}.txt".format(e.prefix.lower()))
        print("Writing test {} ...".format(test_file_name), file=sys.stderr)
        f = open(test_file_name, "w")
        if e.g0:
            write_test_g0(f, e, full_table)
        else:
            write_test_g1(f, e, full_table)

    print("Done", file=sys.stderr)
